# -*- coding: utf-8 -*-
"""Cópia de labCPD-03-Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Et2Jlo_vcVA2cuuonFreO3scibobjzSu

# Disciplina de Classificação e Pesquisa de Dados
 
# Laboratório #3
 
### Implementação (em Python) dos principais algoritmos de classificação por seleção, intercalação e lineares.

## Parte I: algoritmos de seleção (Heapsort e relacionados)

A seguir você encontra uma **versão local do algoritmo heapsort**. Ele utiliza o buildheap que constrói um max-heap a partir do array passado (lembre-se que um max-heap é aquele que tem o maior elemento na raíz, i.e., os pais são maiores ou iguais aos filhos). Você **também encontra funções auxiliares para identificar o filho esquerdo, o filho direito e o pai de um elemento** no array (heap).

O exercício consiste em **implementar a função heapify**, que é usada pelos algoritmos buildheap e heapsort. Também deve **implementar a função heap_max, extract_max e insert_heap**.

**Analise o desempenho delas (tempo, comparações e trocas), em diferentes situações**. 

**Desafios (exercícios extras)**: 
1. implemente uma função build-min-heap que constrói um min-heap. 
2. elabore a função iteractive-build-heap, que constrói um heap inserindo elemento por elemento em um array auxiliar (ou seja, não é local). Analise qual versão apresenta melhor desempenho.
3. elabore uma função build-heap que chama o heapify do início até o último nodo folha, ao invés da função que vimos, que chama do último nodo folha até o início. Analise qual versão apresenta melhor desempenho.
"""

# Bibliotecas necessárias ao script:
import numpy as np  # importa a biblioteca numpy (que trabalha com arrays numéricos)
import time         # importa a biblioteca utilizada para contar o tempo
import pandas as pd # biblioteca para trabalhar com data frames
import math, random
 
################################################
# Algoritmos de ordenação por Seleção
################################################
 
# Seleção direta 
def selection_sort(array): 
    trocas = comparacoes = 0
    for i in range(0, len(array)-1):                                            
        menorchave = i
        for j in range(i, len(array)):                   
            comparacoes = comparacoes + 1
            if array[j] < array[menorchave]: 
                menorchave = j
        if menorchave != i:
            array[i], array[menorchave] = array[menorchave], array[i]
            trocas = trocas + 1        
    return {'trocas':trocas, 'comparacoes':comparacoes}
 
# Heapsort e funções auxiliares
def heap_sort(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}  
    heap_size = len(array)
    qtd_elementos = heap_size-1
    
    build_heap_auxiliar(array, log_operacoes) 
    
    for i in range(qtd_elementos, 0, -1):
        log_operacoes['trocas'] = log_operacoes['trocas'] + 1
        array[i], array[0] = array[0], array[i]          # troca
        heap_size = heap_size - 1
        heapify(array, 0, heap_size, log_operacoes) 
        
    return log_operacoes
 
# igual a seguinte, mas faz o registro do log com base em operações anteriores e posteriores para que o heap_sort conte-as direito
def build_heap_auxiliar(array, log_operacoes):
    ultimo_pai = math.floor(len(array)/2)-1
    for indice in range(ultimo_pai, -1, -1):                                    # range entre [ultimo_pai e -1| (i.e., 0) 
        heapify(array, indice, len(array), log_operacoes)
    return log_operacoes
 
# usada para construir heaps (fora do heap sort):
def build_heap(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}  
    ultimo_pai = math.floor(len(array)/2)-1
    for indice in range(ultimo_pai, -1, -1):                                    # range entre [ultimo_pai e -1| (i.e., 0) 
        heapify(array, indice, len(array), log_operacoes)
    return log_operacoes
 
def filho_e(array, elemento):
    return math.floor(elemento*2+1)
 
def filho_d(array, elemento):
    return math.floor(elemento*2+2)
 
def pai(array, elemento):
    return math.floor(elemento/2)
 
################################################
# Implementação dos seus algoritmos:
   
# heapify: verifica se o elemento na posição passada é um heap e se não for transforma-o em um
# parâmetros: array, índice do elemento a heapificar, tamanho do heap, dicionário de logs
def heapify(array, elemento, heap_size, log_operacoes):
    max = elemento
    left = filho_e(array,max)
    right = filho_d(array,max)

    if left < heap_size and array[left] > array[max]:
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      max = left

    if right < heap_size and array[right] > array[max]:
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      max = right

    if max != elemento:
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      array[elemento],array[max] = array[max], array[elemento]
      log_operacoes['trocas'] = log_operacoes['trocas'] + 1
      heapify(array, max, heap_size, log_operacoes)

    return log_operacoes
 
def heap_max(heap):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    
    max_h = heap[0] 

    return max_h
    
def extract_max(heap):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    if heap != []:
      max = heap[0]
      heap[0] = heap[-1]
      heap.pop()
      heapify(heap, 0, len(heap), log_operacoes)
    return {'max':max, 'log_operacoes':log_operacoes}


def auxHeapInsert(heap, elemento, log_operacoes):
    if elemento != 0:
      pai_ins = pai(heap, elemento)
      if heap[pai_ins] < heap[elemento]:
        heap[pai_ins], heap[elemento] = heap[elemento], heap[pai_ins]
        auxHeapInsert(heap, pai_ins, log_operacoes)

def heap_insert(heap, elemento):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    heap_sizeins = len(heap)
    heap.append(elemento)
    auxHeapInsert(heap, heap_sizeins-1, log_operacoes)
    return log_operacoes

def print_heap(array):
      tam = len(array)
      i=0
      print(f"\n                {array[i]}\n")
      i= i+1
      print(f"         {array[i]}              {array[i+1]}\n")
      i= i+2
      print(f"     {array[i]}      {array[i+1]}       {array[i+2]}      {array[i+3]}\n")
      i= i+3
      if(tam == 8):
        print(f"{array[i]}\n")
      elif(tam == 9):
        print(f"{array[i]}          {array[i+1]}\n")
      else:
        print("\n")

array = [1,2,3,4,5,6,7,8]
build_heap(array)
print(array)
print_heap(array)

array = [9,8,7,6,5,4,3,1]
heap_sort(array)
print(array)
print_heap(array)

heap = [1,2,3,4,5,6,7,8]
build_heap(heap)
print_heap(heap)
print('max: ', heap_max(heap))

resultado = extract_max(heap)
print(resultado['max'])
print_heap(heap)

heap_insert(heap, 30)
build_heap(heap)
print_heap(heap)

"""## Parte II: algoritmos de intercalação

A seguir você encontra uma **versão do algoritmo de merge** e um exemplo de sua aplicação.

Em seguida, há uma célula com vários **algoritmos a implementar**, a saber:
1. **two_way_merge**. 
2. **multi_way_merge**.
2. **merge_sort**.
"""

# Bibliotecas necessárias ao script:
import numpy as np  # importa a biblioteca numpy (que trabalha com arrays numéricos)
import time         # importa a biblioteca utilizada para contar o tempo
import pandas as pd # biblioteca para trabalhar com data frames
import math         # para funções matemáticas 
 
################################################
# Merge
 
def merge(array1, array2): 
    i = j = trocas = comparacoes = 0
    qtd_a1 = len(array1)
    qtd_a2 = len(array2)
    
    elementos = True
    array_final = []
    while i < qtd_a1 and j < qtd_a2:
        if array1[i] <= array2[j]:
            array_final.append(array1[i])
            i = i + 1
        else:
            array_final.append(array2[j])
            j = j + 1
    
    if j < qtd_a2 and i >= qtd_a1:           # array 1 terminou
        array_final.extend(array2[j:qtd_a2+1])
    
    if i < qtd_a1 and j >= qtd_a2:           # array 2 terminou
        array_final.extend(array1[i:qtd_a1+1])
        
    return array_final #, {'trocas':trocas, 'comparacoes':comparacoes}

array1 = [1,2,4,5,7,10,11,12,14,15]
array2 = [2,3,4,6,11,12,14]
 
print(merge(array1, array2))

# Recebe uma lista de arrays e intercala-os 2 a 2
# retorna um array com o resultado da intercalação
def two_way_merge(lst_arrays): 
    array_resultante = []
    
    for array in lst_arrays:
        array_resultante = merge(array_resultante, array)

    return array_resultante

array1 = [1,2,4,5,7,10,11,12,14,15]
array2 = [2,3,4,6,11,12,14]
array3 = [1,2,8,10,11,12,14,15]
array4 = [0,3,25,35,95,1001]
 
print(two_way_merge([array1, array2, array3, array4]))

# Recebe uma lista de arrays e intercala-os usando estrutura similar a heap-min
# retorna um array com o resultado da intercalação

import heapq

def multi_way_merge(lst_arrays): 
    array_resultante = []
    heap = []
    heapq.heapify(heap)

    for array in lst_arrays:
      for i in array:
        heapq.heappush(heap, i)

    while len(heap) > 0:
      array_resultante.append(heapq.heappop(heap))
    
    return array_resultante

print(multi_way_merge([array1, array2, array3, array4]))

def merge_sort(array):
  log_operacoes = {'trocas':0, 'comparacoes':0}  
  x=y=z=0
  if len(array)>1:
    log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
    mid = len(array)//2
    left = array[:mid]
    right = array[mid:]
    merge_sort(left)
    merge_sort(right)
    while x<len(left) and y<len(right):
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      if left[x]<right[y]:
        log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
        array[z]=left[x]
        log_operacoes['trocas'] = log_operacoes['trocas'] + 1
        x+=1
      else:
        array[z]=right[y]
        log_operacoes['trocas'] = log_operacoes['trocas'] + 1
        y+=1
      z+=1   
    while x < len(left):
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      array[z]=left[x]
      log_operacoes['trocas'] = log_operacoes['trocas'] + 1
      x+=1
      z+=1
    while y < len(right):
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      array[z]=right[y]
      log_operacoes['trocas'] = log_operacoes['trocas'] + 1
      y+=1
      z+=1
    
    return log_operacoes

"""## Parte III: algoritmos lineares

A seguir você encontra a implementação dos **algoritmos RADIX-sort LSD e MSD**, além de alguns testes.

Analise-os.

Após, **implemente o counting-sort**.

**Desafios (exercícios extras)**:
1. Modifique o radix_sort_msd_strings de maneira que também funcione em strings com letras maiúsculas (misturadas com as minúsculas e números)
2. Crie uma versão do radix_sort_msd que trabalhe com dígitos numéricos (só para números inteiros)
"""

# Radix-sort LSD
def radix_lsd(array): 
    tamanhoMaximo = False
    RADIX = 10
    digito = 1        
    
    while not tamanhoMaximo:
        buckets = [list() for _ in range(RADIX)]
        tamanhoMaximo = True
        for n in array:
            tmp = n/digito
            buckets[int(tmp % RADIX)].append(n)
            if tamanhoMaximo and tmp>0:
                tamanhoMaximo = False
        a = 0
        for b in range( RADIX ):
            bucket = buckets[b]
            for i in bucket:
                array[a] = i
                a += 1 
        digito *= RADIX            
        
# Radix sort MSD para Strings
def radix_sort_msd_strings(L, i):
    if len(L) <= 1:
        return L
    
    done_bucket = []
    buckets = [ [] for x in range(27+10) ] # um para cada letra do alfabeto [a-z] + digitos [0-9]
 
    for s in L:
        if i >= len(s):
            done_bucket.append(s)
        else:
            pos = ord(s[i]) - ord('a')
            if pos < 0:
                pos = 27 + ord(s[i]) - ord('0')
            buckets[pos].append(s)
 
    buckets = [ radix_sort_msd_strings(b, i + 1) for b in buckets ]
 
    return done_bucket + [ b for blist in buckets for b in blist ]

def countsort(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}  
    k=e=0
    for e in array:                                     # descobre maior (para definir tamanho de C)
      if e > k:
        k = e

    arrayfinal = [0] * len(array)
    VetorAC = [0] * (k + 1)
 
    for i in array:
        VetorAC[i] = VetorAC[i] + 1
 
    total = 0
    for i in range(k + 1):
        Cont = VetorAC[i]
        VetorAC[i] = total
        total += Cont
 
    for i in array:
        arrayfinal[VetorAC[i]] = i
        VetorAC[i] = VetorAC[i] + 1
 
    for i in range(len(array)):
        array[i] = arrayfinal[i]

    return log_operacoes

A = [4, 2, 10, 10, 1, 4, 2, 1, 10, 25, 35,60]
 
# range of list elements
k = 10
 
countsort(A)
print(A)

# geração de um array
 
import numpy as np
import time
 
gerador = np.random.RandomState()
qtd = 100                                # quantidade de elementos a gerar aleatoriamente 
max = qtd                                # valor máximo do intervalo de sorteio
 
arrayrandomico = gerador.randint(0, max+1, qtd)       # gera array com 'qtd' números entre 0 e 'max'
 
print('Array gerado:\n' , arrayrandomico)
countsort(arrayrandomico)
print('Array Ordenado:\n' , arrayrandomico)

# Teste do radix LSD
 
a = np.copy(arrayrandomico) # cria uma cópia do array
 
print('Ordenando...')
tempo = time.process_time()
radix_lsd(a)                    
t = time.process_time() - tempo      
 
print('Array ordenado:\n', a)
print('Tempo: ', t)

radix_sort_msd_strings(['ana', 'marcio', 'joao', 'carlos', 'carla', 'cicero', 'douglas', 'jose'], 0)

radix_sort_msd_strings(['10', '2', '24', '1', '100', '23', '101', '40'], 0)

"""## Parte IV: teste de desempenho de todos os algoritmos

**Inclua** os algoritmos **mergesort, heapsort** e outros que desejar e avalie os seus desempenhos para diferentes tipos e tamanhos de array.
"""

def bubble_sort(array): 
    trocas = comparacoes = pos_troca = 0
    qtd_elementos = len(array)-1
    troca = True
    
    while troca:
        troca = False
        for i in range(0, qtd_elementos):
            comparacoes = comparacoes + 1
            if array[i] > array[i+1]:
                tmp = array[i]
                array[i] = array[i+1]
                array[i+1] = tmp
                troca = True  
                pos_troca = i
                trocas = trocas + 1
        qtd_elementos = pos_troca
                
    return {'trocas':trocas, 'comparacoes':comparacoes}

def particiona(array, esquerda, direita, log_operacoes):
    pivo = esquerda
    i = pivo + 1 
    j = direita
    
    while i<j:
        while (array[j] >= array[pivo]) and (j > esquerda): # procura menor à direita
            j = j - 1
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
        
        while (array[i] < array[pivo]) and (i < direita): # procura maior à esquerda
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
            i = i + 1
            
        if (i<j) and (array[i] > array[j]):
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
            log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
            tmp = array[i]
            array[i] = array[j]
            array[j] = tmp

    if array[j] < array[pivo]:
        log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
        log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
        tmp = array[j]
        array[j] = array[pivo]
        array[pivo] = tmp
    
    return j;

def quick_sort2(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    quicksort2(array, 0, len(array)-1, log_operacoes)
    return log_operacoes

def quicksort2(array, inicio, fim, log_operacoes):
    if fim > inicio:
        # troca primeiro elemento do seguimento com outro aleatório (do seguimento):
        faixa = fim - inicio - 1
        if faixa > 0:
            posicao = random.randrange(faixa) 
        else:
            posicao = 0
        array[inicio], array[inicio+posicao] = array[inicio+posicao], array[inicio]
        
        pivo = particiona(array, inicio, fim, log_operacoes)
        
        # processa menor lado primeiro (para minimizar o consumo da pilha):
        if pivo-inicio > fim - pivo: 
            quicksort2(array, inicio, pivo-1, log_operacoes)
            quicksort2(array, pivo+1, fim, log_operacoes)
        else:
            quicksort2(array, pivo+1, fim, log_operacoes)
            quicksort2(array, inicio, pivo-1, log_operacoes)   
    return log_operacoes

# Avaliação do desempenho de diferentes algoritmos para diferentes quantidades de números
 
# lista que armazena os resultados das medições em memória:
medicoes = []                      
 
# lista de algoritmos a testar (insira o seu, caso elabore outros):
algoritmos = { 
    'HPST': { 'nome': 'Heap sort', 'funcao': heap_sort },
    'SLRT': { 'nome': 'Selection sort', 'funcao': selection_sort},
    'BBLST': { 'nome': 'Bubble sort sort', 'funcao': bubble_sort},
    'MSRT': { 'nome': 'Merge sort', 'funcao': merge_sort}, 
    'QKST': { 'nome': 'Quick sort', 'funcao': quick_sort2},
    'CTST': { 'nome': 'Couting sort', 'funcao': countsort},         
}  
 
# testa o desempenho dos algoritmos para diferentes quantidades (múltiplos de 10):
for qtd in [10**x for x in range(2, 5)]:
    max = qtd
    array = list(range(qtd, 0, -1))                   # array decrescente (pior caso)
    
    print('---------------------------------------------------')
    print('Testando algoritmos com array de tamanho ', qtd)
    print('---------------------------------------------------')
    
    print('Array gerado (', qtd, 'numeros ):\n' , array, '\n') 
    
    for algoritmo in algoritmos:                       # itera sobre cada um dos algoritmos enunciados anteriormente
        print('=> Avaliando ordenação por "', algoritmos[algoritmo]['nome'], '"...')
        
        array_tmp = array.copy()                       # faz cópia do array para não perder
        
        tempo = time.process_time()                     # armazena o tempo de início do processamento
        m = algoritmos[algoritmo]['funcao'](array_tmp ) # aplica algorimo e retorna quantidade de trocas e comparações em 'm'
        t = time.process_time() - tempo                 # verifica o tempo de fim de processamento e calcula a diferença
        print('\nArray ordenado:\n', array_tmp, '\n')
        
        # armazena informações sobre a execução do algoritmo em um dicionário:
        medicao = {}
        medicao['algoritmo']=algoritmo
        medicao['tipo']='D'                              # decrescente
        medicao['quantidade']=qtd
        medicao['trocas']=m['trocas']
        medicao['comparacoes']=m['comparacoes']
        medicao['tempo']=t
        
        medicoes.append(medicao)                          # adiciona medição em uma lista de medições
 
print('Fim do processamento!')
 
# Cria dataframe pandas (i.e., uma tabela) que organiza os dados relacionados com a execução dos algorimos acima
df = pd.DataFrame(medicoes)
cols = ['algoritmo', 'tipo', 'quantidade', 'trocas', 'comparacoes', 'tempo']  # ordem correta das colunas 
df = df[cols]
 
print(df) # imprime os dados de execução dos algoritmos

# agrupa resultados por algoritmo:
df_by_algorithm = df.groupby(['algoritmo']) 

for key, item in df_by_algorithm:
    print(df_by_algorithm.get_group(key), "\n\n")